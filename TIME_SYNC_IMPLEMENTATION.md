# 四传感器时间同步实现文档

## 概述

本实现为ESP32-S3传感器网关系统添加了四个传感器的时间同步功能，通过NTP获取北京时间，使用滑动窗口和最小二乘法计算传感器时间与ESP32时间的线性关系，最终实现高精度的时间戳同步。

## 核心功能

### 1. 时间同步架构

- **NTP时间同步**: 获取ESP32时间与北京时间的差值N
- **滑动窗口**: 存储传感器时间S和ESP32时间E的配对数据
- **最小二乘法**: 计算线性回归参数a和b
- **时间戳计算**: T = a*S + b + N，格式化为时/分/秒/毫秒
- **后台任务**: 拟合计算和NTP同步在后台任务中运行，不影响数据接收速度

### 2. 实现模块

#### TimeSync类 (`include/TimeSync.h`, `src/TimeSync.cpp`)

**主要功能:**
- NTP时间同步获取北京时间差值
- 滑动窗口管理传感器时间对
- 最小二乘法计算线性回归参数
- 时间戳计算和格式化

**关键方法:**
```cpp
bool startTimeSync();                    // 开始时间同步过程
void startBackgroundFitting();           // 开始后台拟合计算
void stopBackgroundFitting();            // 停止后台拟合计算
void addTimePair(uint32_t sensorTimeMs, int64_t espTimeUs);  // 添加时间对（快速）
uint64_t calculateTimestamp(uint8_t sensorId, uint32_t sensorTimeMs);  // 计算同步时间戳（快速）
void performBackgroundFitting();         // 后台拟合计算
uint32_t formatTimestamp(uint64_t timestampMs);              // 格式化时间戳
```

**滑动窗口配置:**
- 窗口大小: 50个数据对
- 最小数据点: 10个（用于线性回归计算）
- 数据有效性验证

#### UartReceiver类修改

**Core0时间戳处理:**
- 在`createSensorFrame()`中添加时间同步逻辑
- 使用`esp_timer_get_time()`获取微秒精度ESP32时间
- 自动添加时间对到滑动窗口（快速操作）
- 计算并格式化最终时间戳（快速操作）
- **优化**: 移除拟合计算，避免影响数据接收速度

#### CommandHandler类扩展

**新增命令:**
- `sync`: 启停时间同步与拟合过程（一键控制）
- `timesyncstatus`: 显示时间同步状态

## 使用流程

### 1. 启停时间同步与拟合

```bash
# 在串口或WebSocket命令中执行（一键启停）
sync
```

### 2. 监控同步状态

```bash
# 查看时间同步状态
timesyncstatus
```

### 3. 服务器端控制

```bash
# 服务器可以通过WebSocket发送sync命令控制时间同步
# 命令格式: {"command": "sync", "command_id": "xxx"}
```

## 时间戳格式

最终输出的时间戳格式为: `HHMMSSmmm`
- HH: 小时 (00-23)
- MM: 分钟 (00-59) 
- SS: 秒 (00-59)
- mmm: 毫秒 (000-999)

例如: `154501651` 表示 15:45:01.651

## 技术细节

### 线性回归计算

使用最小二乘法计算传感器时间S与ESP32时间E的线性关系:
```
E = a * S + b
```

其中:
- S: 传感器时间（毫秒）
- E: ESP32时间（微秒）
- a: 斜率参数
- b: 截距参数（微秒）

### NTP时间同步

- 使用阿里云NTP服务器: `ntp.aliyun.com`, `ntp1.aliyun.com`
- 时区设置为北京时间 (UTC+8)
- 计算NTP时间与ESP32时间的差值N

### 最终时间戳计算

```
T = a * S + b/1000 + N
```

其中:
- T: 最终全局时间戳（毫秒）
- S: 传感器原始时间戳（毫秒）
- a, b: 线性回归参数
- N: NTP时间差（毫秒）

## 性能优化

### Core0优化
- 时间同步计算在Core0上进行，不影响数据接收速度
- 使用非阻塞锁避免数据丢失
- 最小化时间戳计算开销
- **关键优化**: 移除拟合计算，只进行快速时间戳计算

### Core1后台任务
- 时间同步启动/停止命令在Core1上处理
- 拟合计算在Core1后台任务中运行（每5秒一次）
- 避免阻塞Core0的数据接收任务

### 任务分离
- **数据收集**: Core0快速添加时间对到滑动窗口
- **拟合计算**: Core1后台任务定期计算线性回归参数
- **时间戳计算**: Core0使用已有参数快速计算时间戳

## 错误处理

- NTP同步超时处理（10秒超时）
- 时间对有效性验证
- 线性回归计算异常处理
- 网络连接失败处理

## 配置参数

```cpp
#define SLIDING_WINDOW_SIZE 50    // 滑动窗口大小
#define MIN_DATA_POINTS 10        // 最小数据点数
#define NTP_TIMEOUT_MS 10000      // NTP同步超时时间
```

## 状态监控

通过`timesyncstatus`命令可以查看:
- 同步就绪状态
- NTP偏移量
- 线性回归参数
- 有效数据对数量
- 最后更新时间

## 注意事项

1. 需要WiFi连接才能进行NTP同步
2. 建议收集至少10个有效数据对后再使用同步时间戳
3. 时间同步过程可能需要几秒钟完成
4. 传感器数据必须持续接收以维持时间同步精度
5. **新架构**: 拟合计算在后台任务中运行，不会影响数据接收速度
6. **简化控制**: 使用sync命令一键启停时间同步与拟合过程
7. **服务器支持**: 服务器端可通过WebSocket发送sync命令控制时间同步
8. **推荐流程**: 执行sync命令启动，等待数据收集，监控状态
